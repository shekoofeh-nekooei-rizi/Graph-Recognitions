# -*- coding: utf-8 -*-
"""tree_recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UuA1-7G60UYOkbykpFb-nRRsfzZYNxvQ

# **Author: Shekoofe Nekooei Rizi**


This program determines if a given undirected input graph is a tree.

A graph is a tree if and only if it contains no cycles and is connected.

To detect cycles, I implement the Breadth-First Search (BFS) algorithm to explore the graph.

I keep track of the parent of each vertex in the BFS exploration to avoid falsely identifying edges as cycles since each undirected edge between vertices u and v is represented by both u-v and v-u in the adjacency list.

A graph is connected if ALL of the vertices are explored through a Breadth First Search. I check this property in the last line of the code.

This program runs in linear time relative to the size of the input graph: O(n + m), where n is the number of vertices and m is the number of edges.

I test the correctness and performance of the program using both small and big graphs.
"""

from collections import deque

def is_tree(graph):
    """
    Determines whether the input undirected graph is a tree by using Breadth-First Search (to explore the graph and detect cycles) and maintaining a parent dictionary (to avoid misrepresenting edges as cycles, since an undirected edge between vertices u and v is presented by two edges: u - v and v - u).

    After the traversal, the function checks if all vertices were visited to determine if the graph is connected.

    input:
        graph (dict): An adjacency list representing the graph.
        Each key is a vertex and the value is a list of its neighbors.
        For example, graph = {v1: [v2], v2: [v1]} represents a graph which is a single edge between vertices v1 and v2.
        Vertices can be any hashable type (e.g., int, str).

    output:
        bool: True if the graph is a tree, False otherwise.

    """

    if not graph:
        return True

    visited = set()
    Q = deque()
    parent = {}

    start_vertex = next(iter(graph))

    visited.add(start_vertex)
    Q.append(start_vertex)
    parent[start_vertex] = None

    while Q:
        current_v = Q.popleft()
        for neighbor in graph[current_v]:
            if neighbor not in visited:
                visited.add(neighbor)
                Q.append(neighbor)
                parent[neighbor] = current_v
            elif parent[current_v] != neighbor:
                return False
    return len(graph) == len(visited)

"""## **Sample Tests**

**Small samples**
"""

g1 = {1:[]}
is_tree(g1)

g2 = {0: [], 1:[]}
is_tree(g2)

g3 = {'a': ['b', 'c'], 'b': ['a'], 'c':['a']}
is_tree(g3)

g4 = {1: [2, 3], 2: [1], 3:[1], 4: [5], 5: [4]}
is_tree(g4)

c5 = {'A':['B', 'E'], 'B':['A', 'C'], 'C':['B', 'D'], 'D':['C', 'E'], 'E':['A', 'D'] }
is_tree(c5)

"""**Big Samples**

Here I run the program on big graphs.

For this I define graphs such as paths and cycles of length n.

We know that each path is a tree, and each cycle is not a tree.

The expected results are computed in very short time, for large input n's.
"""

def path(n):
    graph = {}
    graph[1] = [2]
    graph[n] = [n-1]
    for v in range(2, n):
        graph[v] = [v-1, v+1]
    return graph

def cycle(n):
    graph = path(n)
    graph[1].append(n)
    graph[n].append(1)
    return graph

c4 = cycle(10**4)

is_tree(c4)

c6 = cycle(10**6)

is_tree(c6)

c7 = cycle(10**7)

is_tree(c7)

p5 = path(10**5)

is_tree(p5)

p6 = path(10**6)

is_tree(p6)

p7 = path(10**7)

is_tree(p7)
# -*- coding: utf-8 -*-
"""split_grpah_recognition_lineartime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pASjqf8RYsvXWraOJirPVKJ78FNWRMCk

# **Author: Shekoofeh Nekooei Rizi**

This program determines if an input graph is a split graph in linear time with respect to the size of the input graph.

Using the **Hammer-Simeone** theorem, I implement the following recognition algorithm,
which is mainly based on the degree sequence of the input graph.

The algorithm first computes the degree of each vertex,
then sorts the vertices by degree in non-increasing order using counting sort (a linear-time sorting algorithm).
[Since each degree is bounded by n-1, the time complexity of the counting sort is O(n+(n-1)) = O(n), thus linear in terms of the input size.]
Next, it identifies the cutoff index in this ordered sequence.

If the vertices before the cutoff form a clique,
and the vertices after it (and the cutoff) form an independent set,
the input is a split graph.
This condition is evaluated through a degree-based equality check.

I test the program with small and big graphs.
"""

def is_split(graph):
    """
    Determines if a `simple` and undirected input graph is a split graph using the Hammer-Simeone theorem.

    This function computes the degree sequence of the graph,
    and sorts the vertices by degree in non-increasing order using counting sort.

    It then identifies the largest index i such that degree[i] >= i.
    It is called the cutoff.

    If the vertices up to the cutoff form a clique, and the remaining vertices form an independent set, the input is a split graph; otherwise, it is not.
    The condition is checked by an equality relation on the degree sequence.

    Input:
        graph (dict): An adjacency list representation of a simple undirected graph.
        (`simple`: there is not more than one edge between each pair of distinct vertices)
        Each key is a vertex, and its value is a list of neighboring vertices. (dict of vertex -> list of neighbors)

    Output:
        bool: True if the input is a split graph, False otherwise.

    """

    # n is the number of vertices in the input graph
    n = len(graph)
    if n <= 1:
        return True

    degree = {vertex: len(graph[vertex]) for vertex in graph}

    # m is the number of edges in the input graph
    m = sum(degree.values()) // 2

    degree_account_array = [0] * n

    for vertex in degree:
        degree_account_array[degree[vertex]] += 1

    sorted_degrees = []
    for i in range(n-1, -1, -1):
        sorted_degrees.extend([i] * degree_account_array[i])

    cutoff = 0
    for i in range(n):
        if sorted_degrees[i] >= i:
            cutoff = i
        else:
            break

    if cutoff == 0 or cutoff == n:
        return True

    if sum(sorted_degrees[:cutoff]) == (cutoff-1) * (cutoff) + sum(sorted_degrees[cutoff:]):
        return True

    return False

"""## **Sample tests**

**Small samples**
"""

path3 = {'a': ['b'], 'b': ['a', 'c'], 'c': ['b']}
is_split(path3)

two_disjoint_edges = {1: [2], 2: [1], 3: [4], 4: [3]}
is_split(two_disjoint_edges)

c4 = {'1': ['2', '4'], '2': ['1', '3'], '3': ['2', '4'], '4': ['1', '3']}
is_split(c4)

c5 = {
    1: [2, 5],
    2: [1, 3],
    3: [2, 4],
    4: [3, 5],
    5: [1, 4]
}
is_split(c5)

# This is the graph in Wikipedia entry for "Split graph"
graph = {
    1: [2, 3, 4, 5, 6],
    2: [1, 3, 4, 5, 6, 7, 8, 10],
    3: [1, 2, 4, 5, 8, 10],
    4: [1, 2, 3, 5],
    5: [1, 2, 3, 4, 5],
    6: [1, 2, 5],
    7: [2],
    8: [2, 3],
    9: [],
    10: [2, 3]
}
is_split(graph)

graph = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3],
    3: [2]
}
is_split(graph)

"""**Big Samples**

In this section, I provide larger graph samples to test the performance of the program.

We know star graphs
(a graph consisting of one vertex connected to all other vertices and no additional edges)
are split graphs. They are sparse graphs.


We also know that threshold graphs are split graphs.
[more about threshold graphs:](https://en.wikipedia.org/wiki/Threshold_graph)

I generate threshold graphs with n vertices by applying n random operations (isolated or dominating). Depending on the sequence of operations, the resulting graph can vary from sparse to dense.

On the other hand, complete bipartite graphs with each part having more than one vertex are not split graphs.
They can be quite dense.

I test the correctness and performance of the recognition algorithm using these three graph families.

The result for each case is shown in a table, which also includes
the size of the input graph and the time taken to compute if the input is a split graph or not.
This time does NOT include the time required to generate the input graph itself.
"""

def star_graph(n):
    """
    Generates a star graph with n peripheral vertices connected to a central vertex 0.

    Input:
        n (int): Number of peripheral vertices.

    Output:
        dict: Adjacency list representation of the star graph.
    """
    graph = {v: [0] for v in range(1,n+1)}
    graph[0] = list(range(1, n+1))
    return graph

import time
def test_star_graph(n):
    """
    Generates a star graph and tests whether it is a split graph.

    This function performs the following steps:
    1. Creates a star graph with n peripheral vertices using the above function.
    3. Computes basic graph statistics: number of vertices, number of edges, and
       total size (vertices + edges).
    4. Runs the is_split result on the graph and measures its execution time.
    5. Prints a summary table showing:
       - Whether the graph is a split graph
       - Number of vertices
       - Number of edges
       - Total size of the graph
       - Execution time of 'is_split' in seconds

    Input:
        n (int): Number of peripheral vertices (in other words, the number of vertices in the generated graph is n+1)
    """

    G = star_graph(n)
    num_vertices = n+1
    num_edges = n
    graph_size = num_vertices + num_edges

    start = time.time()
    result = is_split(G)
    finish = time.time()
    running_time = finish - start

    # Print table
    print(f"\n{'Is Split':<12} {'Vertices':<12} {'Edges':<12} {'Size':<12} {'Time (s)':<10}")
    print(f"{'-'*60}")
    print(f"{str(result):<12} {num_vertices:<12} {num_edges:<12} {graph_size:<12} {running_time:.6f}")

test_star_graph(100)

test_star_graph(10**4)

test_star_graph(10**5)

test_star_graph(10**6)

import random

def random_threshold_graph(n):
    """
    Generates a threshold graph based on a sequence of random operations.

    A threshold graph is constructed iteratively.
    It starts with a single vertex.
    For each subsequent operation:
    - If the operation is 'dominating', the new vertex is connected to all existing vertices.
    - If the operation is 'isolated', the new vertex is connected to no existing vertices.

    This function simulates the process, returning the graph's adjacency list and total edge count.

    Input:
        n (int): Number of vertices

    Output:
        a tuple of:
        dict: Adjacency list representation of the star graph.
        and
        number of edges in the generated graph

    """

    def generate_random_operations(n):
        """
        It generates an array of n random operations for constructing a threshold graph.
        Operaton types are either 'isolated' or 'dominating'.

        Input:
            n (int): The number of operations to generate.

        Output:
            list: A list of n strings, where each string is 'dominating' or 'isolated'.
        """
        operations = ['dominating', 'isolated']
        random_ops = [random.choice(operations) for _ in range(n)]
        return random_ops

    graph = {}
    current_vertex_id = 0
    edge_count = 0

    operations = generate_random_operations(n)
    if not operations:
        return {0: []}, 0

    graph[current_vertex_id] = []
    current_vertex_id += 1

    for op in operations:
        graph[current_vertex_id] = []
        if op == 'dominating':
            for existing_vertex in range(current_vertex_id):
                graph[current_vertex_id].append(existing_vertex)
                graph[existing_vertex].append(current_vertex_id)
                edge_count += 1
        current_vertex_id += 1

    return graph, edge_count

import time

def test_random_threshold_graph(n):
    """
    Generates a treshold graph with n vertices, (n is also the number of steps of random operations)
    Then, runs the is_split function on it, and prints a summary table including:
    - Whether the graph is split
    - Number of vertices
    - Number of edges
    - Size of the graph (vertices + edges)
    - Execution time of the  is_split function in seconds

    Input:
        n (int): Number of vertices of the graph, it is also the number of operation to generate this random treshold graph.
    """

    graph, num_edges = random_threshold_graph(n)
    num_vertices = n
    graph_size = num_vertices + num_edges

    start = time.time()
    result = is_split(graph)
    finish = time.time()
    running_time = finish - start

    # Print table
    print(f"\n{'Is Split':<12} {'Vertices':<12} {'Edges':<12} {'Size':<12} {'Time (s)':<10}")
    print(f"{'-'*60}")
    print(f"{str(result):<12} {num_vertices:<12} {num_edges:<12} {graph_size:<12} {running_time:.6f}")

test_random_threshold_graph(100)

test_random_threshold_graph(10**4)

test_random_threshold_graph(10**4)

test_random_threshold_graph(10**4)

test_random_threshold_graph(10**4)

import networkx as nx

def test_complete_biPartite(m, n):
    """
    Generates a complete bipartite graph and tests whether it is a split graph.

    This function performs the following steps:
    1. Creates a complete bipartite graph with one part containing m vertices
       and the other part containing n vertices using the NetworkX package.
    2. Converts the NetworkX graph to a dictionary format compatible with 'is_split' input.
    3. Computes basic graph statistics: number of vertices, number of edges, and
       total size (vertices + edges).
    4. Runs the is_split result on the graph and measures its execution time.
    5. Prints a summary table showing:
       - Whether the graph is a split graph
       - Number of vertices
       - Number of edges
       - Total size of the graph
       - Execution time of 'is_split' in seconds

    Input:
        m (int): Number of vertices in one part of the bipartite graph.
        n (int): Number of vertices in the other part of the bipartite graph.
    """

    G = nx.complete_bipartite_graph(m, n)
    G_valid_format = {node: list(G[node]) for node in G.nodes()}
    num_vertices = G.number_of_nodes()
    num_edges = G.number_of_edges()
    graph_size = num_vertices + num_edges

    start = time.time()
    result = is_split(G_valid_format)
    finish = time.time()
    running_time = finish - start

    # Print table
    print(f"\n{'Is Split':<12} {'Vertices':<12} {'Edges':<12} {'Size':<12} {'Time (s)':<10}")
    print(f"{'-'*60}")
    print(f"{str(result):<12} {num_vertices:<12} {num_edges:<12} {graph_size:<12} {running_time:.6f}")

test_complete_biPartite(10**2, 10**2)

test_complete_biPartite(10**3, 10**3)

test_complete_biPartite(5*10**3, 2*10**3)

test_complete_biPartite(10**4, 2*10**3)
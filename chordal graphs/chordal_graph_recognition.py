# -*- coding: utf-8 -*-
"""chordal_graph_recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XCeu_XFGC81iUA7Nn5eJ0BbfBmv4cYwr

# **Author: Shekoofeh Nekooei Rizi**


This program determines if a given input graph is chordal or not.

To do this, I implemented the classic algorithm introduced by Rose, Tarjan, and Lueker in their work "Algorithmic Aspects of Vertex Elimination on Graphs".

The process, first, involves making a **Lexicographical Breadth First Search** ordering of the vertices.

I did this part by direct implementation of the **partition refinement** technique described in the paper "A simple linear time algorithm for cograph recognition" by Bretscher, Corneil, Habib, and Paul.


Next, the algorithm checks whether the reverse of this ordering forms a **perfect elimination ordering**  -- a property unique to chordal graphs.

If the condition is satisfied, the graph is chordal; otherwise, it is not.
"""

def Lex_BFS(graph):
    """
    Computes a Lexicographic Breadth-First Search (LexBFS) ordering of the vertices
    of an undirected graph using partition refinement technique.

    Input:
        graph (dict): An adjacency list representation of an undirected graph.
            Each key is a vertex, and its value is a list of neighboring vertices.
            For example, graph = {v1: [v2], v2: [v1]} represents a graph which is a single edge
            between vertices v1 and v2.
            Vertices can be any hashable type (e.g., int, str).

    Output:
        list: A list of vertices in LexBFS order.
    """

    order = []

    def partition_refinement(parts):
        """
        Takes a vertex from the first part, adds it to the order, and refines the rest based on adjacency to that vertex.

        Input:
            parts (list of sets): Current partition of unvisited vertices.

        Output:
            list of sets: New partition with each part split into neighbors and non-neighbors of the selected vertex.
        """
        vertex = parts[0].pop()
        order.append(vertex)

        new_parts = []
        for p in parts:
            if not p:
                continue
            neighbors = p.intersection(graph[vertex])
            non_neighbors = p.difference(graph[vertex])

            if neighbors:
                new_parts.append(neighbors)
            if non_neighbors:
                new_parts.append(non_neighbors)

        return new_parts

    parts = [set(graph.keys())]

    for _ in range(len(graph)):
        parts = partition_refinement(parts)

    return order

def is_chordal(graph):
    """
    Determines if the input graph is chordal using the LexBFS-based PEO test.

    A graph is chordal if and only if the reverse of some Lexicographical BFS order is a perfect elimination ordering (PEO).

    Input:
        graph (dict): An adjacency list representation of an undirected graph.
        Each key is a vertex, and its value is a list of neighboring vertices. (dict of vertex -> list of neighbors)

    Output:
        bool: True if the graph is chordal, False otherwise.
    """

    reverse_order_LexBFS = list(reversed(Lex_BFS(graph)))

    position = {vertex: index for index, vertex in enumerate(reverse_order_LexBFS)}

    for vertex in reverse_order_LexBFS:

        forward_neighbors = [neighbor for neighbor in graph[vertex] if position[vertex] < position[neighbor]]
        if not forward_neighbors:
            continue

        leftmost_neighbor = min(forward_neighbors, key = lambda x: position[x])

        for neighbor in forward_neighbors:
            if not (neighbor in graph[leftmost_neighbor] or neighbor == leftmost_neighbor):
                return False

    return True

"""## **Sample Tests**

**Small Samples**

Here I provide some small examples to test this program.
"""

c3 = {'a': ['b', 'c'], 'b': ['a', 'c'], 'c': ['a', 'b']}
is_chordal(c3)

c4 = {1: [2, 4],
      2: [1, 3],
      3: [2, 4],
      4: [1, 3]}

is_chordal(c4)

p5 = {'a':['b'], 'b': ['a', 'c'], 'c': ['b', 'd'], 'd': ['c', 'e'], 'e': ['d'] }
is_chordal(p5)

g = {'a': ['b', 'c', 'd'],
     'b':['a', 'd'],
     'c':['a', 'e'],
     'd':['a', 'b', 'f'],
     'e':['c'],
     'f': ['d']}

is_chordal(g)

g = {'A': ['B', 'C', 'D', 'E', 'G'],
     'B': ['A', 'C', 'D', 'E', 'F'],
     'C': ['A', 'B', 'D', 'F'],
     'D': ['A', 'B', 'C', 'G'],
     'E': ['A', 'B'],
     'F': ['B', 'C'],
     'G': ['A', 'D']}
is_chordal(g)

g = {'0': ['1', '2', '3', '4', '5'], '1': ['0', '2', '5'], '2': ['0', '1', '3'], '3': ['0', '2', '4'], '4': ['0', '3', '5'], '5': ['0', '1', '4']}

is_chordal(g)

feder_graph_7 = {1: [3, 4, 5, 6],
                 2: [3],
                 3: [2, 4],
                 4: [3, 5],
                 5: [4, 6],
                 6: [5, 7],
                 7: [6]}

is_chordal(feder_graph_7)

"""**Big Samples**

In this section, I provide larger graph samples to test and see the performance of the program.

To do so, I define a specific graph structure and call it feder_graph($n$).

This graph consists of a path of n-1 vertices and an additional vertex that is connected to all vertices of this path except the first and the last ones.

By choosing a large input n, we can generate sizable graphs with n vertices and 2n-5 edges.

We know that graphs with this structure are chordal.

I studied this graph structure here in "Obstructions to partitions of chordal graphs", "Partitioning chordal graphs" and my thesis: "Matrix partition of chordal graphs".

I also test the program with Mycielski graphs.

Mycielskians are clearly not chordal. This makes them a useful counterexample to verify the correctness of the algorithm.

These graphs grow exponentially through iterations of the Mycielski construction.
"""

import time

def feder_graph(n):
    graph = {}
    graph[1] = [vertex for vertex in range(3, n)]
    graph[2] = [3]
    graph[n] = [n-1]
    for v in range(3, n):
        graph[v] = [1, v-1, v+1]

    return graph

feder_graph(10)

is_chordal(feder_graph(10))

is_chordal(feder_graph(1000))

g4 = feder_graph(10000)
is_chordal(g4)

g5 = feder_graph(100000)
start_time = time.time()
print(is_chordal(g5), " (This graph is chordal.)")
finish_time = time.time()
print("Running time: ", finish_time - start_time, " seconds")

from networkx.generators.mycielski import mycielski_graph

M5 = mycielski_graph(5)
print("\nLevel five Mycielski ", M5, "\n")
Mycielski_5_valid_format = {node: list(M5[node]) for node in M5.nodes()}
Mycielski_5_valid_format

print("Is Mycielsky graph, level five, chodal?\n" )
is_chordal(Mycielski_5_valid_format)

M10 = mycielski_graph(10)
Mycielski_10_valid_format = {node: list(M10[node]) for node in M10.nodes()}

print("Level ten Mycielski: ", M10)
print("\nIs Mycielsky graph, level ten, chordal?\n")
is_chordal(Mycielski_10_valid_format)

M12 = mycielski_graph(12)
Mycielski_12_valid_format = {node: list(M12[node]) for node in M12.nodes()}

print("Level twelve Mycielski: ", M12)
print("\nIs Mycielsky graph, level twelve, chordal?\n")
is_chordal(Mycielski_12_valid_format)

M13 = mycielski_graph(13)
Mycielski_13_valid_format = {node: list(M13[node]) for node in M13.nodes()}

print("\nLevel thirteen Mycielski: ", M13)
print("\nIs Mycielsky graph, level thirteen, chordal?\n")

start = time.time()
print(is_chordal(Mycielski_13_valid_format))
finish = time.time()
print("\nRunning time: ", finish - start, " seconds")
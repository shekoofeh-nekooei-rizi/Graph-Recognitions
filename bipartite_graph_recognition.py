# -*- coding: utf-8 -*-
"""bipartite_graph_recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YQwkTe-oC7r-Ug7tWHI36BI2uOiddPSe

# **Author: Shekoofeh Nekooei Rizi**

This program determines if a given input graph is bipartite or not.

To do this, I implement Breadth First Search combined with a two-coloring technique.

A graph is bipartite if and only if it is 2-colorable.

This program runs in linear time relative to the size of the input graph:

O(n+m) where n is the number of vertices and m is the number of edges of the input.

I test the correctness and performance of the program through small and big samples.
"""

from collections import deque

def is_bipartite(graph):
    """
    Determines whether the input undirected graph is bipartite using
    Breadth-First Search and two-coloring.

    input:
        graph (dict): An adjacency list representing the graph.
        Each key is a vertex and the value is a list of its neighbors.
        For example, graph = {v1: [v2], v2: [v1]} represents a graph which is a single edge between vertices v1 and v2.
        Vertices can be any hashable type (e.g., int, str).

    output:
        bool: True if the graph is bipartite, False otherwise.

    """
    color = {}
    Q = deque()
    for vertex in graph:
        if vertex not in color:
            Q.append(vertex)
            color[vertex] = "white"

            while Q:
                current_v = Q.popleft()
                for neighbor in graph[current_v]:
                    if neighbor not in color:
                        if color[current_v] == "white":
                            color[neighbor] = "black"
                        else:
                            color[neighbor] = "white"
                        Q.append(neighbor)
                    elif color[neighbor] == color[current_v]:
                        return False
    return True

"""# **Sample Tests**

Even-length cycles, trees, and grid graphs are known to be bipartite, while any graph containing an induced cycle of odd length is not.


We use these well-known properties to help verify the correctness of the program.


**Small Samples**

"""

graph = {1: [2], 2:[1], 3:[4], 4:[3]}
is_bipartite(graph)

c3 = {'a': ['b', 'c'], 'b':['a', 'c'], 'c':['a', 'b']}
is_bipartite(c3)

c4 = {0:[1, 3], 1:[0, 2], 2:[1, 3], 3:[0, 2]}
is_bipartite(c4)

c5 = {1:[2, 5], 2:[1, 3], 3:[2, 4], 4:[3, 5], 5:[4, 1]}
is_bipartite(c5)

tree = {'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F', 'G'],
        'D': ['B'],
        'E': ['B'],
        'F': ['C'],
        'G': ['C']}

is_bipartite(tree)

from networkx.generators.lattice import grid_2d_graph
d = grid_2d_graph(3, 2)
d = {node: list(d[node]) for node in d.nodes()}
is_bipartite(d)

"""**Big Samples**

Each of the following examples is a large graph with at least one million vertices and one million edges.

The expected results are computed within a few seconds.
"""

from networkx.generators.lattice import grid_2d_graph
from networkx.generators.classic import cycle_graph

c_e = cycle_graph(10**6)
print('This is an Even-length Cycle', c_e)
c_e = {node: list(c_e[node]) for node in c_e.nodes()}

print('Is it bipartite?')
is_bipartite(c_e)

c_o = cycle_graph(10**6+1)
print('This is an Odd-length Cycle', c_o)
c_o = {node: list(c_o[node]) for node in c_o.nodes()}

print('Is it bipartite? ')
is_bipartite(c_o)

c_o2 = cycle_graph(10**7+1)
print('This is another Odd-length Cycle', c_o2)
c_o2 = {node: list(c_o2[node]) for node in c_o2.nodes()}

print('Is it bipartite? ')
is_bipartite(c_o2)

g = grid_2d_graph(10**3, 10**3)
print('This is a grid', g)
g = {node: list(g[node]) for node in g.nodes()}

print('Is it bipartite? ')
is_bipartite(g)